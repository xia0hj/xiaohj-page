# HTTP && 浏览器 && 计算机网络

## 1. 浏览器中输入网址后发生了什么

1. 首先要解析 URL。如果协议或者主机名不合法，那就换成用搜索引擎去搜索；如果 URL 中有非法字符，还要进行转义处理。
2. 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新
的请求。
3. 然后要获取 IP 地址。
   1. 首先会判断本地是否有该域名的 IP 地址的缓存，会查找浏览器和系统的 DNS 缓存，以及 HOST 文件。
   2. 如果没有则向本地 DNS 服务器发起请求，如果也没有则 DNS 服务器会从根域名服务器开始逐级请求
4. 得到 IP 地址后，进行 TCP 三次握手，<font color="orange">参考 15</font>
5. 如果用的是 HTTPS 协议，TCP 三次握手前还有一个 TLS 握手过程，<font color="orange">参考 14</font>
6. 成功建立连接后，浏览器发送请求，服务器返回一个 html 作为响应
7. 浏览器解析渲染页面，<font color="orange">参考 2</font>

## 2. 浏览器渲染页面的过程

1. 首先解析接收到的 HTML 文件，转化成 DOM 树
2. 然后解析 CSS，生成 CSSOM 规则树
3. 根据 DOM 树和 CSSOM 树合并成渲染树，渲染树包含了要显示的节点以及样式信息
4. 根据渲染树来进行布局，这一阶段浏览器就是要搞清楚各个节点在页面中的位置和大小，也叫做回流、重排，<font color="orange">参考 3</font>
5. 最后就是绘制阶段，遍历渲染树将各个节点显示在屏幕上

## 3. 回流/重排 和 重绘

1. 回流/重排：当渲染树的某些元素因为尺寸、位置等属性发生改变，影响到布局，导致要重新去构建那一部分受影响的渲染树
2. 重绘：当渲染树的某些元素更新了一些不影响布局的属性，比如说改了颜色，浏览器就会跳过布局阶段，直接重新绘制元素
3. 回流一定会发生重绘，重绘不一定会回流，回流所需成本要比重绘高
4. 回流的产生：
   1. 元素大小改变：内外边距、边框、宽高等等
   2. 内容变化：用户在 input 输入框里输入文字
   3. 浏览器窗口大小发生改变
   4. 添加或删除可见的 DOM 元素
   5. 设置 style 属性
   6. 调用 getComputedStyle() 也会引起回流，为了获取到最新准确的数据
5. 减少回流的方法：
   1. 不要一条一条地去修改 style 属性，可以先预定义好 class 样式，然后修改 DOM 的 class
   2. 避免在循环中读取 DOM 的某些会引起回流的属性，例如 offsetWidth、offsetHeight，应该在循环之前先保存起来
   3. 不要用 table 布局，因为 table 中某个元素一旦触发回流会造成整个 table 的重新布局

## 4. 浏览器解析时遇到 js 怎么处理

1. 解析 HTML 时遇到 js，浏览器会暂停解析，将控制权移交给 js 引擎，等 js 引擎运行完毕，浏览器再从中断的地方恢复继续解析。
2. 如果想首屏渲染快一点，就把 script 标签放到 body 的末尾；或者给 script 标签加上 defer 或 async 属性，<font color="orange">参考 5</font>。

## 5. script 标签的 defer、async 属性

1. 没有 defer 或 async，会暂停 html 的解析，立即加载和执行 js
2. defer：延迟执行。不阻塞 html 解析并行加载 js，但等到 html 解析完成后再执行 js。
3. async：异步执行。同样不阻塞 html 解析并行加载 js，一旦加载完成就马上阻塞解析并执行 js。

## 6. GET 和 POST 区别

1. 应用：GET 用于请求资源，不会对服务器资源产生影响；POST 用于提交数据，会影响服务器资源。
2. 缓存：GET 请求会被浏览器主动缓存下来，并留下历史记录，POST不会
3. 参数：GET 的参数放在 URL 中，不安全，POST 的参数放在请求体 body 中
4. 幂等性：GET具有幂等性，没有副作用；而POST不是

## 7. 跨域

1. 使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。我的项目中就是这样，用 express 去做跨域请求
2. JSONP：利用 script 标签的 src 没有跨域限制，src 的链接后拼接指定一个回调函数名，服务器返回包装数据的回调函数，前端拿到函数执行后就取到了数据。
3. CORS：看这里 TODO [https://www.ruanyifeng.com/blog/2016/04/cors.html]
4. 使用 websocket 协议，这个协议没有同源限制。

## 8. 浏览器的同源策略

1. 我的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则就不属于同一个域；目的主要是为了保证用户的信息安全。
2. 同源策略主要限制了 3 个方面：
   1. 第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
   2. 第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
   3. 第三个是当前域下 ajax 无法发送跨域请求。

## 9. HTTP 状态码

1. 1xx 表示协议处理的中间状态，101 更换协议。
2. 2xx 表示成功，200 成功，204 成功但不返回实体内容，206 成功处理部分请求，用于断点续传和分块下载。
3. 3xx 表示重定向，301永久重定向，302临时重定向。
4. 4xx 表示请求报文有误，400请求报文语法错误，403服务器拒绝，404在服务器上找不到资源。
5. 5xx 表示服务器端发生错误，500 服务器内部错误，502 网关错误，503 服务器过载。

## 10. HTTP 报文格式

1. 请求报文：请求行（请求方法、URL 等信息）、请求头、header 与 body 之间的空行、请求内容实体
2. 响应报文：状态行（状态码）、响应头、header 与 body 之间的空行、响应内容实体

## 11. Content-Type

1. application/json：告诉服务器消息主体是序列化后的 JSON 字符串。
2. multipart/form-data：通常表单上传文件时使用该种方式。
3. text/xml：该种方式主要用来提交 XML 格式的数据。
4. application/octet-stream：二进制流，文件下载一般是这个。
5. image/png：image 开头的图片，此外还有 gif、jpeg。

## 12. HTTP 缓存机制

1. 分为强制缓存和协商缓存。
   1. 强制缓存：假如浏览器判断缓存没有过期，那么无需向服务器发送这个资源请求了，可以直接使用该缓存。
   2. 协商缓存：每次使用缓存前都要向服务器发送请求，由服务器来判断缓存是否有效，不能浏览器自己来判断。
2. 响应头的 Cache-Control 字段控制强制缓存，，属性值如下：
   1. max-age=3600：缓存有效时间，单位毫秒
   2. no-store：禁止缓存，每次都从服务器拿最新的资源
   3. no-cache：使用协商缓存，与 no-store 互斥
   4. public：表示该资源可以被中间层的代理服务器缓存
   5. private：表示该资源只能由浏览器缓存，禁止中间层缓存，与 public 互斥
3. 如果使用了协商缓存，服务器返回资源文件时，可以在响应头中带上资源标识 Last-Modified（资源文件上次修改时间）和 ETag（资源文件唯一标识字符串），浏览器会记录下来这两个值；下次发送请求时，会在请求头中通过 If-Modified-Since 和 If-None-Match 带上这两个值，由服务器判断浏览器的缓存资源是否过期，过期则返回 200 状态及新的资源文件，未过期则只返回 304 状态码；对比 Last-Modified 和 ETag，优先使用 ETag，因为 Last-Modified 只能精确到秒
4. 相关博客文章：[HTTP缓存——强制缓存和协商缓存](https://blog.csdn.net/weixin_52148548/article/details/124843301)

## 13. 请求头中用于协商缓存的 ETag

1. nginx 的 etag 由 Last-Modified 和 content-length 两个字段值转换成十六进制组合而成。
2. etag 发生改变不代表资源文件一定发生改变，假如重新生成了相同的资源文件，导致 Last-Modified 发生变化而 content-length 不变，则生成 etag 也变了，但文件内容实则没有变化。

## 14. HTTPS 原理 / TLS 握手

1. 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
3. 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
4. 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
5. 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。
6. 使用 3 个随机数的原因：默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解，所以用 3 个提高安全性

## 15. TCP/IP 三次握手

1. 第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的随机数。它代表的是客户端数据的初始序号。
2. 第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，然后向 客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加 1。
3. 第三次握手，客户端接收到服务器的肯定应答后，会向服务器端发送一个对服务器端的报文段的确认。第三次握手可以在报文段中携带数据。
4. 为什么要 3 次握手：三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。

## 16. 四次挥手

1. 第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的连接。发送后客户端进入 FIN_WAIT_1 状态。
2. 第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。
3. 第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAST_ACK 状态。
4. 第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，这个时间为 2 倍的报文最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被释放了。
5. 为什么要 4 次挥手：因为 TCP 连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。
6. 最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。

## 17. localStorage sessionStorage cookie 区别

1. 存储大小：
   1. cookie 不能超过 4k。
   2. localStorage 和 sessionStorage 大得多，5M 左右。
2. 有效时间：
   1. localStorage 长期存储，除非主动删除。
   2. sessionStorage：每个标签页独立保存一份，在关闭标签时删除，刷新不会删除。
   3. cookie：设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
3. 作用域：
   1. sessionStorage：只在当前标签页中共享。
   2. localStorage 和 cookie 在所有同源窗口中共享。

## 18. 计算机网络七层模型

1. 物理层：底层数据传输，如网线；网卡标准。转发器。
2. 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。网桥或桥接器
3. 网络层：IP协议，ICMP协议，IGMP协议，ARP协议，定义IP编址，定义路由功能；如不同设备的数据转发。路由器
4. 传输层：端到端传输数据的基本功能；如 TCP、UDP。网关
5. 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
6. 表示层：数据格式表示，基本压缩加密功能。
7. 应用层：各种应用软件，包括 Web 应用。

## 19. 二维码原理

1. 用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。
2. 当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示。
3. 当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页。

## 20. 如何检测浏览器版本

检查 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写。

## 21. 前端登录流程

1. 当用户点击登录时，前端带着用户名和密码去调用后端接口。
2. 后端校验密码，验证失败返回错误信息，验证成功返回 token。
3. 前端将 token 存储到 localStorage 中，然后跳转页面登录成功。
4. 前端每次访问需要登录状态的页面时都检查 token 是否存在，想后端发送请求时在请求头带上 token。

## 22. 搜索引擎优化 SEO

1. 用好 HTML 的语义化标签。
2. 重要内容 HTML 代码放前面；搜索引擎抓取 HTML 是从上到下，有的搜索引擎抓取长度有限制，放前面保证重要内容被抓取。
3. 重要内容不用 js 来输出，爬虫不会执行 js 去获取内容。
4. 少用 iframe，搜索引擎不抓取 iframe 的内容。
5. 非装饰性的图片加 alt。

## 23. 如何让浏览器用最新的 js

1. js 文件名后面加个版本号。
2. 响应头的 Cache-Control 属性设为 no-store，<font color="orange">参考 12</font>。
3. 协商缓存，用 Last-Modified 或者 ETag 来控制是否过期，<font color="orange">参考 12</font>。

## 24. 正向代理和反向代理

1. 正向代理：隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。
2. 反向代理：隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向代理器一般用来实现负载平衡。

## 25. 多网站共享登录 / 单点登录

1. 在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
2. 我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该 token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将页面重定向会单点登录页面。

## 26. CDN

CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。

## 27. HTTP 1.0 / 1.1 / 2.0

1. HTTP 1.1
   1. 新增缓存机制，etag、If-Modefied-Since、If-None-Match 等，<font color="orange">参考 12</font>
   2. 支持长连接：默认开启，Connection: keep-alive，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟
   3. 新增状态码：
   4. 新增请求方法：PUT、DELETE 等
   5. 在 header 新增了 range 字段，允许只请求资源的一部分，可以用来做分块下载、断点续传
2. HTTP 2.0
   1. 二进制传输：HTTP1 的解析是基于文本的
   2. header 压缩

## 28. 加密

1. base64：`window.btoa()` 是加密，`window.atob()` 是解密
2. MD5：加密不可逆，将 MD5 加密后的用户密码保存到数据库，校验时是拿加密后的密文来比对。
3. AES：对称加密，加密和解密的密钥相同
4. RSA：非对称加密，加密密钥和解密密钥不相同，用公钥加密后，只能用对应的私钥解密
